// ============================================== Описание алгоритмов

Описание алгоритмов есть здесь - https://cloud.mail.ru/public/yyh2/BuT7m5VKZ/OS_lecture_9.pdf .

1. Алгоритм списка свободных блоков - вкратце, ты просто хранишь список свободных
кусков в памяти, когда нужно занять кусок, ты просто ищешь наиболее близкий кусок свободный,
откусываешь от него нужную часть и отдаешь. При освобождении памяти ты возвращаешь
свободный кусок на место и пытаешься его слить с другими, чтобы не было слишком сильного дробления
памяти на куски (это называется дефрагментация памяти).

2. Алгоритм двойников. Он чуть сложнее чем предыдущий, но в целом и в лекции есть про него
и нагуглить можно.

// ==============================================

 Сравнение двух аллокаторов:

    1. Алгоритм списка свободных блоков.
    2. Алгоритм двойников.

№1 Простота реализации.

    Первый алгоритм проще в реализации.

№2 Фактор использования.

    Второй алгоритм в силу своей специфики может выделять только блоки размера
степени двойки, из-за чего используется лишняя память. У первого алгоритма такого
недостатка нет. В процессе тестирования аллокаторов обнаружилось, что там, где
первый аллокатор спокойно справляется со своей задачей, второй падает из за
недостатка памяти.

№3 Скорость выделения блоков.

    У обоих алгоритмов скорость выделения блоков практически одинаковая, однако
первый алгоритм оказался чуть быстрее.

№4 Скорость освобождения блоков.

    У обоих алгоритмов скорость освобождения блоков практически одинаковая, однако
при долгом использовании, второй алгоритм демонстрирует слегка большую скорость по
сравнению с первым. При тесте с большим количеством блоков и небольшой длительностью
использования второй алгоритм показал ускорение в 20-30% при освобождении блоков.

№5 Общая производительность.

    Несмотря на небольшой прирост в скорости у второго алгоритма при длительном
использовании, в среднем первый алгоритм показывает более высокую скорость работы.

    Итог:

    По итогам тестирования первый алгоритм в среднем оказался лучше по скорости,
легче в реализации и менее расточительным по памяти. Второй алгоритм демонстрирует
более высокую скорость лишь в определенных случаях.
